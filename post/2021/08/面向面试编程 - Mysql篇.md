## 面向面试编程 - Mysql篇
本系列目的是收纳总结各种面试八股，带着面试问题学习总结

### 事务
（1）事务的四个特性

* 原子性(A)：原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。原子性的实现通过 Undo Log，如果事务提交失败，通过 Undo Log 回滚
* 一致性(C)：最终目的，需要其他三个辅助，软件层面实现保障。
* 隔离性(I)：多个事务之间并发需要隔离，涉及到事务的四个隔离级别，即可能出现的问题
* 持久性(D)：一个事务一旦被提交，对数据库改变是永久的。持久性的实现通过 Redo Log，如果事务已经提交，但是磁盘没有及时将数据更新，可以通过 Redo Log 二次修改，保证改变是永久的。

（2）什么是脏读？不可重复读？幻读？

* 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
* 不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间提交了一个事务，更新的原有的数据，**要点是变更**。
* 幻读(Phantom Read)：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的， **要点是插入**。

（3）请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

 * 读未提交(READ-UNCOMMITTED)：最低的隔离级别，允许读取尚未提交的数据变更。
 * 读取已提交(READ-COMMITTED)： 允许读取并发事务已经提交的数据。
 * 可重复读(REPEATABLE-READ)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。
 * 可串行化(SERIALIZABLE)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行

![avatar](../../../static/images/2021/隔离级别.png)

逻辑梳理：事务通过锁保障隔离性，可能出现的问题是脏读、不可重复读和幻读。为了解决脏读，我们通过读不加锁，写修改删除枷锁，达到RC；但是仍会出现可重复读的情况，于是针对写，我们提出 MVVC，达到RR；最后，针对读，通过 Next-Key 锁，在RR级别解决了幻读问题。

- 隔离级别与锁的关系
    - 在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突
    - 在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；
    - 在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。
    - SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

### Mysql涉及到的锁

* 表级锁（锁定整个表）
* 页级锁（锁定一页）
* 行级锁（锁定一行）
* 共享锁（S锁，MyISAM 叫做读锁）
* 排他锁（X锁，MyISAM 叫做写锁）
* 间隙锁（NEXT-KEY锁）
* 悲观锁（抽象性，不真实存在这个锁）
* 乐观锁（抽象性，不真实存在这个锁）

