## Mysql 索引知识总结
本文聚焦问题：
索引是什么，Mysql 的 InnoDB 引擎如何实现，为什么要用 B+ 树，什么是聚簇非聚簇索引，索引有哪些类型，如何通过索引提高 Mysql 性能，索引有哪些 Tricks

![avatar](../../../static/images/2021/Mysql%20索引.png)

### 索引是什么
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针MySQL 在存储数据的时候是以数据页为最小单位的，所以索引的结果实际上是页，一个页中包括连续主键的行。我们主要聚焦 InnoDB，B+ 树索引。

### B+ 树索引
Mysql 的 InnoDB 引擎使用的是 B+ 树索引，也就是我们传统意义上的索引.

为什么要用 B+ 树？我们更换为两个问题，什么是B+树，为什么不用 Hash 或者 B-Tree？

#### 什么是 B+ 树？
B+ 树是一种多路平衡查询树，非叶子节点仅存放 key，所有的 value 都存放于叶子节点，所以他的叶子节点是天然有序的。

Tips:

* B+ 树索引并不能找到一个给定键值的具体行，只能找到数据行所在的页，然后把数据库读入内存，在内存中进行查找。
* InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB

#### 为什么不用 Hash 或者 B-Tree？
我们从两个方面解释：

* InnoDB 需要支持的场景和功能需要在特定查询上拥有较强的性能；
* CPU 将磁盘上的数据加载到内存中需要花费大量的时间，这使得 B+ 树成为了非常好的选择；


总结一下：

* 为什么不用 Hash：无法解决范围查找、全局扫描等问题。哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；
* 为什么不用 B-Tree：由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；

### 聚簇索引与非聚簇索引
B+ 树索引可以分为 Clustered Index 和 Secondary Index，由于中文翻译千奇百怪，我们只需要理解两者的关键不同即可。

* Clustered Index 基于主键列，一张表只有一个，叶子节点的页存放整行内容；

* Secondary Index 对任意列，一张表可以有多个，叶子节点存放指向 Clustered Index 的主键。

Tips：

* 回表：根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的



### 参考资料
[1]. [MySQL索引原理，一篇从头到尾讲清楚](https://juejin.cn/post/6931901822231642125)