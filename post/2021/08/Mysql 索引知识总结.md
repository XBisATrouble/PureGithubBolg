## Mysql 索引知识总结
本文聚焦问题：
索引是什么，Mysql 的 InnoDB 引擎如何实现，为什么要用 B+ 树，什么是聚簇非聚簇索引，索引有哪些类型，如何通过索引提高 Mysql 性能，索引有哪些 Tricks

![avatar](../../../static/images/2021/Mysql%20索引.png)

### 索引是什么
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针MySQL 在存储数据的时候是以数据页为最小单位的，所以索引的结果实际上是页，一个页中包括连续主键的行。我们主要聚焦 InnoDB，B+ 树索引。

### B+ 树索引
Mysql 的 InnoDB 引擎使用的是 B+ 树索引，也就是我们传统意义上的索引.

为什么要用 B+ 树？我们更换为两个问题，什么是B+树，为什么不用 Hash 或者 B-Tree？

#### 什么是 B+ 树？
B+ 树是一种多路平衡查询树，非叶子节点仅存放 key，所有的 value 都存放于叶子节点，所以他的叶子节点是天然有序的。

Tips:

* B+ 树索引并不能找到一个给定键值的具体行，只能找到数据行所在的页，然后把数据库读入内存，在内存中进行查找。
* InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB

#### 为什么不用 Hash 或者 B-Tree？
我们从两个方面解释：

* InnoDB 需要支持的场景和功能需要在特定查询上拥有较强的性能；
* CPU 将磁盘上的数据加载到内存中需要花费大量的时间，这使得 B+ 树成为了非常好的选择；


总结一下：

* 为什么不用 Hash：无法解决范围查找、全局扫描等问题。哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；
* 为什么不用 B-Tree：由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；

### 聚簇与非聚簇索引
B+ 树索引可以分为 Clustered Index 和 Secondary Index，由于中文翻译千奇百怪，我们只需要理解两者的关键不同即可。

* Clustered Index 基于主键列，一张表只有一个，叶子节点的页存放整行内容；
* Secondary Index 对任意列，一张表可以有多个，叶子节点存放指向 Clustered Index 的主键。

### 联合索引
联合索引是指对表上多个列进行索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

 **最左匹配原则**

最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a, b, d的顺序可以任意调整。

in 和 = 可以乱序，比如 a = 1 and b = 2 and c = 3 建立 (a,b,c) 索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。

### 索引覆盖
回表是指根据 Secondary Index 查询到的结果并没有查找的字段值，此时就需要再次根据主键从 Clustered Index 的根节点开始查找，这样再次查找到的记录才是完成的

但是，Secondary Index 一定会回表查询吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为 **"索引覆盖"**。



### 参考资料
[1]. [MySQL索引原理，一篇从头到尾讲清楚](https://juejin.cn/post/6931901822231642125)